#!/usr/bin/env python3
"""
dateiKopieren.py - File copying and clipboard management script

This script is part of the asynchronous workflow managed by PythonServer.py.
It handles file copying operations and manages clipboard content with the 
transcript generated by voiceToGoogle.py.
"""

import os
import sys
import shutil
from pathlib import Path

# Try to import clipboard functionality
try:
    import pyperclip
    CLIPBOARD_AVAILABLE = True
except ImportError:
    CLIPBOARD_AVAILABLE = False
    print("Warning: pyperclip not available, clipboard operations disabled")

def ensure_directory(directory):
    """Ensure a directory exists, create if necessary"""
    try:
        Path(directory).mkdir(parents=True, exist_ok=True)
        return True
    except Exception as e:
        print(f"Error creating directory {directory}: {e}")
        return False

def copy_file(source, destination):
    """Copy a file from source to destination"""
    try:
        # Ensure destination directory exists
        dest_dir = os.path.dirname(destination)
        if dest_dir and not ensure_directory(dest_dir):
            return False
            
        shutil.copy2(source, destination)
        print(f"File copied: {source} -> {destination}")
        return True
    except Exception as e:
        print(f"Error copying file {source} to {destination}: {e}")
        return False

def copy_transcript_to_clipboard(transcript_file="transkript.txt"):
    """Copy transcript content to clipboard"""
    try:
        if not os.path.exists(transcript_file):
            print(f"Transcript file not found: {transcript_file}")
            return False
            
        with open(transcript_file, 'r', encoding='utf-8') as f:
            content = f.read().strip()
            
        if not content:
            print("Transcript file is empty")
            return False
            
        if not CLIPBOARD_AVAILABLE:
            print("Warning: Clipboard functionality not available in headless environment")
            print(f"Transcript content (would be copied): {len(content)} characters")
            print(f'Preview: "{content[:50]}{"..." if len(content) > 50 else ""}"')
            # In headless mode, we still consider this a success since content is available
            return True
            
        pyperclip.copy(content)
        print(f"Transcript copied to clipboard: {len(content)} characters")
        print(f'Preview: "{content[:50]}{"..." if len(content) > 50 else ""}"')
        return True
        
    except Exception as e:
        print(f"Error copying transcript to clipboard: {e}")
        # In headless environments, pyperclip errors are expected
        if "copy/paste mechanism" in str(e).lower():
            print("Note: Running in headless environment - clipboard not available")
            print("Transcript content is still accessible via file")
            return True
        return False

def backup_recordings(source_dir=None, backup_dir="Aufnahmen_Backup"):
    """Create backups of recording files"""
    # If no source directory specified, use the standard recording location
    if source_dir is None:
        source_dir = str(Path.home() / "Desktop" / "v2_Tripple S" / "Aufnahmen")
        # Also try local directory as fallback
        if not os.path.exists(source_dir):
            source_dir = "Aufnahmen"
    
    success_count = 0
    error_count = 0
    
    if not os.path.exists(source_dir):
        print(f"Source directory not found: {source_dir}")
        # Try to find recordings in alternative locations
        alternative_dirs = [
            "Aufnahmen",
            str(Path.home() / "Desktop" / "v2_Tripple S" / "Aufnahmen"),
            "."
        ]
        
        for alt_dir in alternative_dirs:
            if alt_dir != source_dir and os.path.exists(alt_dir):
                # Check if directory contains audio files
                audio_files = []
                for ext in ['.wav', '.mp3', '.m4a', '.flac', '.ogg', '.aac']:
                    audio_files.extend(list(Path(alt_dir).glob(f'*{ext}')))
                
                if audio_files:
                    print(f"Using alternative source directory: {alt_dir}")
                    source_dir = alt_dir
                    break
        
        if not os.path.exists(source_dir):
            print("No recording directories found with audio files")
            return True  # No files to backup is not an error condition
    
    # Ensure backup directory exists
    if not ensure_directory(backup_dir):
        return False
    
    print(f"Backing up recordings from {source_dir} to {backup_dir}...")
    
    # Common audio file extensions
    audio_extensions = ['.wav', '.mp3', '.m4a', '.flac', '.ogg', '.aac']
    
    try:
        for file_path in Path(source_dir).rglob('*'):
            if file_path.is_file() and file_path.suffix.lower() in audio_extensions:
                # Calculate relative path to maintain directory structure
                relative_path = file_path.relative_to(source_dir)
                backup_path = Path(backup_dir) / relative_path
                
                if copy_file(str(file_path), str(backup_path)):
                    success_count += 1
                else:
                    error_count += 1
                    
    except Exception as e:
        print(f"Error during backup process: {e}")
        return False
    
    print(f"Backup completed: {success_count} files backed up, {error_count} errors")
    return error_count == 0

def organize_files():
    """Organize files in the workspace"""
    operations = []
    
    # Define file organization rules
    organization_rules = [
        {
            'source_pattern': '*.wav',
            'destination': 'Aufnahmen/',
            'description': 'Audio recordings'
        },
        {
            'source_pattern': '*.txt',
            'destination': 'Transkripte/',
            'description': 'Text transcripts'
        },
        {
            'source_pattern': '*.png',
            'destination': 'BilderVertex/',
            'description': 'Generated images'
        },
        {
            'source_pattern': '*.jpg',
            'destination': 'BilderVertex/',
            'description': 'Generated images'
        }
    ]
    
    print("Organizing files...")
    
    for rule in organization_rules:
        pattern = rule['source_pattern']
        dest_dir = rule['destination']
        description = rule['description']
        
        # Find matching files
        matching_files = list(Path('.').glob(pattern))
        
        if matching_files:
            print(f"Processing {len(matching_files)} {description} files...")
            
            # Ensure destination directory exists
            ensure_directory(dest_dir)
            
            for file_path in matching_files:
                # Skip the active aufnahme.wav file to prevent moving the current recording
                if file_path.name == "aufnahme.wav":
                    print(f"  Skipping active recording file: {file_path.name}")
                    continue
                    
                if file_path.parent.name == dest_dir.rstrip('/'):
                    # File is already in the correct directory
                    continue
                    
                destination = Path(dest_dir) / file_path.name
                
                # Handle filename conflicts
                counter = 1
                while destination.exists():
                    stem = file_path.stem
                    suffix = file_path.suffix
                    destination = Path(dest_dir) / f"{stem}_{counter}{suffix}"
                    counter += 1
                
                if copy_file(str(file_path), str(destination)):
                    operations.append(f"Moved {file_path.name} to {dest_dir}")
                    # Remove original file after successful copy
                    try:
                        file_path.unlink()
                    except Exception as e:
                        print(f"Warning: Could not remove original file {file_path}: {e}")
    
    if operations:
        print(f"File organization completed: {len(operations)} operations")
        for op in operations:
            print(f"  ✓ {op}")
        return True
    else:
        print("No files needed organizing")
        return True

def main():
    """Main file copying and management workflow"""
    print("=== File Copying and Management ===")
    print("Starting file operations...")
    
    success_operations = 0
    total_operations = 0
    
    # Operation 1: Copy transcript to clipboard
    print("\n1. Copying transcript to clipboard...")
    total_operations += 1
    if copy_transcript_to_clipboard():
        success_operations += 1
        print("✓ Transcript copied to clipboard successfully")
    else:
        print("✗ Failed to copy transcript to clipboard")
    
    # Operation 2: Backup recordings
    print("\n2. Creating backup of recordings...")
    total_operations += 1
    if backup_recordings():
        success_operations += 1
        print("✓ Recording backup completed successfully")
    else:
        print("✗ Recording backup failed or no recordings found")
    
    # Operation 3: Organize files
    print("\n3. Organizing workspace files...")
    total_operations += 1
    if organize_files():
        success_operations += 1
        print("✓ File organization completed successfully")
    else:
        print("✗ File organization failed")
    
    # Summary
    print(f"\n=== File Operations Summary ===")
    print(f"Completed: {success_operations}/{total_operations} operations")
    
    if success_operations == total_operations:
        print("✓ All file operations completed successfully")
        return True
    else:
        print(f"✗ {total_operations - success_operations} operations failed")
        return False

if __name__ == "__main__":
    try:
        success = main()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\nFile operations interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}")
        sys.exit(1)
